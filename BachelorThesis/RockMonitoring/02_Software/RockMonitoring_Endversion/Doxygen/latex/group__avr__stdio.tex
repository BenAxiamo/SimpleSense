\hypertarget{group__avr__stdio}{}\section{$<$stdio.\+h$>$\+: Standard IO facilities}
\label{group__avr__stdio}\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \hyperlink{group__avr__stdio_gac45fdeab51c3197c1e7c4ec7beabaca9}{getchar}()~\hyperlink{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{fgetc}(\hyperlink{group__avr__stdio_gaaca70138f0cb63ddb026921afc635179}{stdin})
\item 
\#define \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE}~struct \hyperlink{struct____file}{\+\_\+\+\_\+file}
\item 
\#define \hyperlink{group__avr__stdio_gaaca70138f0cb63ddb026921afc635179}{stdin}~(\+\_\+\+\_\+iob\mbox{[}0\mbox{]})
\item 
\#define \hyperlink{group__avr__stdio_ga0c0ef221f95f64e8632451312fd18cc8}{stdout}~(\+\_\+\+\_\+iob\mbox{[}1\mbox{]})
\item 
\#define \hyperlink{group__avr__stdio_ga5ce35bd5ba5021fd3b2e951e8f497656}{stderr}~(\+\_\+\+\_\+iob\mbox{[}2\mbox{]})
\item 
\#define \hyperlink{group__avr__stdio_ga59adc4c82490d23754cd39c2fb99b0da}{E\+OF}~(-\/1)
\item 
\#define \hyperlink{group__avr__stdio_ga793fcb8f10b6b8746d4186012929ddf1}{fdev\+\_\+set\+\_\+udata}(stream,  u)~do \{ (stream)-\/$>$udata = u; \} while(0)
\item 
\#define \hyperlink{group__avr__stdio_gac04f5faa8e86a4ce4ae084d85386af40}{fdev\+\_\+get\+\_\+udata}(stream)~((stream)-\/$>$udata)
\item 
\#define {\bfseries fdev\+\_\+setup\+\_\+stream}(stream,  p,  g,  f)
\item 
\#define \hyperlink{group__avr__stdio_ga79826a1c733e4f67843256d34ad64352}{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD}~\+\_\+\+\_\+\+S\+RD
\item 
\#define \hyperlink{group__avr__stdio_ga822a791a1c06a12b95c14ace75b48ad2}{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE}~\+\_\+\+\_\+\+S\+WR
\item 
\#define \hyperlink{group__avr__stdio_ga93db55caeeaf13488a635f8896a6bdf3}{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW}~(\+\_\+\+\_\+\+S\+RD$\vert$\+\_\+\+\_\+\+S\+WR)
\item 
\#define \hyperlink{group__avr__stdio_ga132917c782a0ba854c3ae9abe57c3b12}{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR}~(-\/1)
\item 
\#define \hyperlink{group__avr__stdio_ga280c47b9edff2751b8dbb9a715dc44c5}{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF}~(-\/2)
\item 
\#define {\bfseries F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM}(p,  g,  f)
\item 
\#define \hyperlink{group__avr__stdio_gaa1226b8f734a1b5148d931ae2908c45d}{fdev\+\_\+close}()~((void)0)
\item 
\#define \hyperlink{group__avr__stdio_ga247111653f3e91bf2cb4930d590d8201}{putc}(\+\_\+\+\_\+c,  \+\_\+\+\_\+stream)~\hyperlink{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}{fputc}(\+\_\+\+\_\+c, \+\_\+\+\_\+stream)
\item 
\#define \hyperlink{group__avr__stdio_ga61e2590ae5f2f2e351365640d2ac755a}{putchar}(\+\_\+\+\_\+c)~\hyperlink{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}{fputc}(\+\_\+\+\_\+c, \hyperlink{group__avr__stdio_ga0c0ef221f95f64e8632451312fd18cc8}{stdout})
\item 
\#define \hyperlink{group__avr__stdio_gacff255b3a0079ebb1516e8a4eb23a6fb}{getc}(\+\_\+\+\_\+stream)~\hyperlink{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{fgetc}(\+\_\+\+\_\+stream)
\item 
\#define {\bfseries clearerror}(s)~do \{ (s)-\/$>$flags \&= $\sim$(\+\_\+\+\_\+\+S\+E\+RR $\vert$ \+\_\+\+\_\+\+S\+E\+OF); \} while(0)\hypertarget{group__avr__stdio_gaf197d8e0d92942f712358933ed045e5e}{}\label{group__avr__stdio_gaf197d8e0d92942f712358933ed045e5e}

\item 
\#define {\bfseries feof}(s)~((s)-\/$>$flags \& \+\_\+\+\_\+\+S\+E\+OF)\hypertarget{group__avr__stdio_ga7b12b132d859855004e3f8ad1a07cf86}{}\label{group__avr__stdio_ga7b12b132d859855004e3f8ad1a07cf86}

\item 
\#define {\bfseries ferror}(s)~((s)-\/$>$flags \& \+\_\+\+\_\+\+S\+E\+RR)\hypertarget{group__avr__stdio_gabd64fde16e8d1ef091de992b6a1c902d}{}\label{group__avr__stdio_gabd64fde16e8d1ef091de992b6a1c902d}

\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$ {\bfseries fdevopen} (int($\ast$\+\_\+\+\_\+put)(char, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$), int($\ast$\+\_\+\+\_\+get)(\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$))\hypertarget{group__avr__stdio_gaf723c10444079126c59ef483569edd3f}{}\label{group__avr__stdio_gaf723c10444079126c59ef483569edd3f}

\item 
int \hyperlink{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{fclose} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)
\item 
int \hyperlink{group__avr__stdio_ga55b25ecbfd3811ea4495d1f235e2e186}{vfprintf\+\_\+P} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)
\item 
int \hyperlink{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}{fputc} (int \+\_\+\+\_\+c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int {\bfseries putc} (int \+\_\+\+\_\+c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)\hypertarget{group__avr__stdio_ga12f30bdc3bab93519424652d3d18c973}{}\label{group__avr__stdio_ga12f30bdc3bab93519424652d3d18c973}

\item 
int {\bfseries putchar} (int \+\_\+\+\_\+c)\hypertarget{group__avr__stdio_gae7a584b0cbf21a025f3376e0ee72250f}{}\label{group__avr__stdio_gae7a584b0cbf21a025f3376e0ee72250f}

\item 
int \hyperlink{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{printf} (const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga418e63921ed6259e873cd21b6c5c8e6e}{printf\+\_\+P} (const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga0b15be24dd9db93355e1f62937fdfd9a}{vprintf} (const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)
\item 
int \hyperlink{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}{sprintf} (char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga2b829d696b17dedbf181cd5dc4d7a31d}{sprintf\+\_\+P} (char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga77070c245d4ca4f7ec7d7144260fb875}{snprintf} (char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga53ff61856759709eeceae10aaa10a0a3}{snprintf\+\_\+P} (char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_gaaeb1bbe21a1b9b50b207ab059a67993f}{vsprintf} (char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)
\item 
int \hyperlink{group__avr__stdio_gaf47f5141509d1e434f9da2b27287a707}{vsprintf\+\_\+P} (char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)
\item 
int \hyperlink{group__avr__stdio_gac92e8c42a044c8f50aad5c2c69e638e0}{vsnprintf} (char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)
\item 
int \hyperlink{group__avr__stdio_ga2071feb5c92bf50a6bd508a07ead9515}{vsnprintf\+\_\+P} (char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)
\item 
int \hyperlink{group__avr__stdio_ga0e41285401c397eb29692205a95fcd9c}{fprintf} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga36173b4a8551b61811089198beec69d9}{fprintf\+\_\+P} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga19c2bbe9ce4af9f0a7e3448387004fd3}{fputs} (const char $\ast$\+\_\+\+\_\+str, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_ga3d25813cb225ca410518a3f48eb00caa}{fputs\+\_\+P} (const char $\ast$\+\_\+\+\_\+str, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_ga33f7bd99d40bf6f68a00d5507d65363d}{puts} (const char $\ast$\+\_\+\+\_\+str)
\item 
int \hyperlink{group__avr__stdio_gab4de83c560c79bf880fa39b997d61610}{puts\+\_\+P} (const char $\ast$\+\_\+\+\_\+str)
\item 
size\+\_\+t \hyperlink{group__avr__stdio_gadd5777719a41713629a62b68c239a774}{fwrite} (const void $\ast$\+\_\+\+\_\+ptr, size\+\_\+t \+\_\+\+\_\+size, size\+\_\+t \+\_\+\+\_\+nmemb, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{fgetc} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int {\bfseries getc} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)\hypertarget{group__avr__stdio_ga63ed7073e1bd288b25277b3186050ff0}{}\label{group__avr__stdio_ga63ed7073e1bd288b25277b3186050ff0}

\item 
int \hyperlink{group__avr__stdio_gab4f9b130166e5811519513d6178c1ae3}{ungetc} (int \+\_\+\+\_\+c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
char $\ast$ \hyperlink{group__avr__stdio_ga00d34a8bff0293d2d6f4563d248d8fb2}{fgets} (char $\ast$\+\_\+\+\_\+str, int \+\_\+\+\_\+size, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
char $\ast$ \hyperlink{group__avr__stdio_gaf577dcba9afe50a9d068d0b69ac85d2f}{gets} (char $\ast$\+\_\+\+\_\+str)
\item 
size\+\_\+t \hyperlink{group__avr__stdio_ga54fa47156a34c1659a29ed96e46e3518}{fread} (void $\ast$\+\_\+\+\_\+ptr, size\+\_\+t \+\_\+\+\_\+size, size\+\_\+t \+\_\+\+\_\+nmemb, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
void \hyperlink{group__avr__stdio_gaaa6d255675688c736c99ebd32f2a7214}{clearerr} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_ga47b00053272d6443c9befdb1304002cb}{feof} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int \hyperlink{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}{ferror} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream)
\item 
int {\bfseries vfscanf} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)\hypertarget{group__avr__stdio_ga67bae1ad3af79809fd770be392f90e21}{}\label{group__avr__stdio_ga67bae1ad3af79809fd770be392f90e21}

\item 
int \hyperlink{group__avr__stdio_ga6c6b5b881ce8f4739777ff3a615e988a}{vfscanf\+\_\+P} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)
\item 
int \hyperlink{group__avr__stdio_ga0beb4fd9ff6833a364e3ce60370de058}{fscanf} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga7aec94e711ad64724076666586a26839}{fscanf\+\_\+P} (\hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{F\+I\+LE} $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga3f0edc16dcabb5344d59d42cf7682102}{scanf} (const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga0fb7fd70cd7618f27d8219c97e61bcf3}{scanf\+\_\+P} (const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_ga8bd4b760f67791a54e73111734caa82f}{vscanf} (const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)
\item 
int \hyperlink{group__avr__stdio_ga5507d0e1bbfd387fbb2ffcfd8f5dca6f}{sscanf} (const char $\ast$\+\_\+\+\_\+buf, const char $\ast$\+\_\+\+\_\+fmt,...)
\item 
int \hyperlink{group__avr__stdio_gaeca11dc4b3757ed4ff2f2a4950eba117}{sscanf\+\_\+P} (const char $\ast$\+\_\+\+\_\+buf, const char $\ast$\+\_\+\+\_\+fmt,...)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{struct____file}{\+\_\+\+\_\+file} $\ast$ {\bfseries \+\_\+\+\_\+iob} \mbox{[}$\,$\mbox{]}\hypertarget{group__avr__stdio_ga7feff3ec68109146090137cef9b023d2}{}\label{group__avr__stdio_ga7feff3ec68109146090137cef9b023d2}

\end{DoxyCompactItemize}


\subsection{Detailed Description}

\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{stdio_8h}{stdio.h}>} 
\end{DoxyCode}


\paragraph*{Introduction to the Standard IO facilities}

This file declares the standard IO facilities that are implemented in {\ttfamily avr-\/libc}. Due to the nature of the underlying hardware, only a limited subset of standard IO is implemented. There is no actual file implementation available, so only device IO can be performed. Since there\textquotesingle{}s no operating system, the application needs to provide enough details about their devices in order to make them usable by the standard IO facilities.

Due to space constraints, some functionality has not been implemented at all (like some of the {\ttfamily printf} conversions that have been left out). Nevertheless, potential users of this implementation should be warned\+: the {\ttfamily printf} and {\ttfamily scanf} families of functions, although usually associated with presumably simple things like the famous \char`\"{}\+Hello, world!\char`\"{} program, are actually fairly complex which causes their inclusion to eat up a fair amount of code space. Also, they are not fast due to the nature of interpreting the format string at run-\/time. Whenever possible, resorting to the (sometimes non-\/standard) predetermined conversion facilities that are offered by avr-\/libc will usually cost much less in terms of speed and code size.

\paragraph*{Tunable options for code size vs. feature set}

In order to allow programmers a code size vs. functionality tradeoff, the function \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} which is the heart of the printf family can be selected in different flavours using linker options. See the documentation of \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} for a detailed description. The same applies to vfscanf() and the {\ttfamily scanf} family of functions.

\paragraph*{Outline of the chosen A\+PI}

The standard streams {\ttfamily stdin}, {\ttfamily stdout}, and {\ttfamily stderr} are provided, but contrary to the C standard, since avr-\/libc has no knowledge about applicable devices, these streams are not already pre-\/initialized at application startup. Also, since there is no notion of \char`\"{}file\char`\"{} whatsoever to avr-\/libc, there is no function {\ttfamily fopen()} that could be used to associate a stream to some device. (See \hyperlink{group__avr__stdio_stdio_note1}{note 1}.) Instead, the function {\ttfamily fdevopen()} is provided to associate a stream to a device, where the device needs to provide a function to send a character, to receive a character, or both. There is no differentiation between \char`\"{}text\char`\"{} and \char`\"{}binary\char`\"{} streams inside avr-\/libc. Character {\ttfamily \textbackslash{}n} is sent literally down to the device\textquotesingle{}s {\ttfamily put()} function. If the device requires a carriage return ({\ttfamily \textbackslash{}r}) character to be sent before the linefeed, its {\ttfamily put()} routine must implement this (see \hyperlink{group__avr__stdio_stdio_note2}{note 2}).

As an alternative method to fdevopen(), the macro fdev\+\_\+setup\+\_\+stream() might be used to setup a user-\/supplied F\+I\+LE structure.

It should be noted that the automatic conversion of a newline character into a carriage return -\/ newline sequence breaks binary transfers. If binary transfers are desired, no automatic conversion should be performed, but instead any string that aims to issue a C\+R-\/\+LF sequence must use {\ttfamily \char`\"{}\textbackslash{}r\textbackslash{}n\char`\"{}} explicitly.

For convenience, the first call to {\ttfamily fdevopen()} that opens a stream for reading will cause the resulting stream to be aliased to {\ttfamily stdin}. Likewise, the first call to {\ttfamily fdevopen()} that opens a stream for writing will cause the resulting stream to be aliased to both, {\ttfamily stdout}, and {\ttfamily stderr}. Thus, if the open was done with both, read and write intent, all three standard streams will be identical. Note that these aliases are indistinguishable from each other, thus calling {\ttfamily \hyperlink{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{fclose()}} on such a stream will also effectively close all of its aliases (\hyperlink{group__avr__stdio_stdio_note3}{note 3}).

It is possible to tie additional user data to a stream, using \hyperlink{group__avr__stdio_ga793fcb8f10b6b8746d4186012929ddf1}{fdev\+\_\+set\+\_\+udata()}. The backend put and get functions can then extract this user data using \hyperlink{group__avr__stdio_gac04f5faa8e86a4ce4ae084d85386af40}{fdev\+\_\+get\+\_\+udata()}, and act appropriately. For example, a single put function could be used to talk to two different U\+A\+R\+Ts that way, or the put and get functions could keep internal state between calls there.

\paragraph*{Format strings in flash R\+OM}

All the {\ttfamily printf} and {\ttfamily scanf} family functions come in two flavours\+: the standard name, where the format string is expected to be in S\+R\+AM, as well as a version with the suffix \char`\"{}\+\_\+\+P\char`\"{} where the format string is expected to reside in the flash R\+OM. The macro {\ttfamily P\+S\+TR} (explained in \hyperlink{group__avr__pgmspace}{$<$avr/pgmspace.\+h$>$\+: Program Space Utilities}) becomes very handy for declaring these format strings.

\label{group__avr__stdio_stdio_without_malloc}%
\hypertarget{group__avr__stdio_stdio_without_malloc}{}%
\paragraph*{Running stdio without \hyperlink{group__avr__stdlib_ga4996af830ebe744d9678e5251dfd3ebd}{malloc()}}

By default, fdevopen() requires \hyperlink{group__avr__stdlib_ga4996af830ebe744d9678e5251dfd3ebd}{malloc()}. As this is often not desired in the limited environment of a microcontroller, an alternative option is provided to run completely without \hyperlink{group__avr__stdlib_ga4996af830ebe744d9678e5251dfd3ebd}{malloc()}.

The macro fdev\+\_\+setup\+\_\+stream() is provided to prepare a user-\/supplied F\+I\+LE buffer for operation with stdio.

\subparagraph*{Example}


\begin{DoxyCode}
\textcolor{preprocessor}{#include <\hyperlink{stdio_8h}{stdio.h}>}

\textcolor{keyword}{static} \textcolor{keywordtype}{int} uart\_putchar(\textcolor{keywordtype}{char} c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{FILE} *stream);

\textcolor{keyword}{static} \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{FILE} mystdout = FDEV\_SETUP\_STREAM(uart\_putchar, NULL,
                                         \hyperlink{group__avr__stdio_ga822a791a1c06a12b95c14ace75b48ad2}{\_FDEV\_SETUP\_WRITE});

\textcolor{keyword}{static} \textcolor{keywordtype}{int}
uart\_putchar(\textcolor{keywordtype}{char} c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{FILE} *stream)
\{

  \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\(\backslash\)n'})
    uart\_putchar(\textcolor{charliteral}{'\(\backslash\)r'}, stream);
  loop\_until\_bit\_is\_set(UCSRA, UDRE);
  UDR = c;
  \textcolor{keywordflow}{return} 0;
\}

\textcolor{keywordtype}{int}
main(\textcolor{keywordtype}{void})
\{
  init\_uart();
  \hyperlink{group__avr__stdio_ga0c0ef221f95f64e8632451312fd18cc8}{stdout} = &mystdout;
  \hyperlink{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{printf}(\textcolor{stringliteral}{"Hello, world!\(\backslash\)n"});

  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


This example uses the initializer form F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+A\+M() rather than the function-\/like fdev\+\_\+setup\+\_\+stream(), so all data initialization happens during C start-\/up.

If streams initialized that way are no longer needed, they can be destroyed by first calling the macro \hyperlink{group__avr__stdio_gaa1226b8f734a1b5148d931ae2908c45d}{fdev\+\_\+close()}, and then destroying the object itself. No call to \hyperlink{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{fclose()} should be issued for these streams. While calling \hyperlink{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{fclose()} itself is harmless, it will cause an undefined reference to \hyperlink{group__avr__stdlib_gafb8699abb1f51d920a176e695ff3be8a}{free()} and thus cause the linker to link the malloc module into the application.

\paragraph*{Notes}

\label{group__avr__stdio_stdio_note1}%
\hypertarget{group__avr__stdio_stdio_note1}{}%
\begin{DoxyParagraph}{Note 1\+:}
It might have been possible to implement a device abstraction that is compatible with {\ttfamily fopen()} but since this would have required to parse a string, and to take all the information needed either out of this string, or out of an additional table that would need to be provided by the application, this approach was not taken.
\end{DoxyParagraph}
\label{group__avr__stdio_stdio_note2}%
\hypertarget{group__avr__stdio_stdio_note2}{}%
\begin{DoxyParagraph}{Note 2\+:}
This basically follows the Unix approach\+: if a device such as a terminal needs special handling, it is in the domain of the terminal device driver to provide this functionality. Thus, a simple function suitable as {\ttfamily put()} for {\ttfamily fdevopen()} that talks to a U\+A\+RT interface might look like this\+:
\end{DoxyParagraph}

\begin{DoxyCode}
\textcolor{keywordtype}{int}
uart\_putchar(\textcolor{keywordtype}{char} c, \hyperlink{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{FILE} *stream)
\{

  \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'\(\backslash\)n'})
    uart\_putchar(\textcolor{charliteral}{'\(\backslash\)r'});
  loop\_until\_bit\_is\_set(UCSRA, UDRE);
  UDR = c;
  \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


\label{group__avr__stdio_stdio_note3}%
\hypertarget{group__avr__stdio_stdio_note3}{}%
\begin{DoxyParagraph}{Note 3\+:}
This implementation has been chosen because the cost of maintaining an alias is considerably smaller than the cost of maintaining full copies of each stream. Yet, providing an implementation that offers the complete set of standard streams was deemed to be useful. Not only that writing {\ttfamily \hyperlink{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{printf()}} instead of {\ttfamily fprintf(mystream, ...)} saves typing work, but since avr-\/gcc needs to resort to pass all arguments of variadic functions on the stack (as opposed to passing them in registers for functions that take a fixed number of parameters), the ability to pass one parameter less by implying {\ttfamily stdin} or stdout will also save some execution time. 
\end{DoxyParagraph}


\subsection{Macro Definition Documentation}
\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF@{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF}}
\index{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF@{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF}{_FDEV_EOF}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+F\+D\+E\+V\+\_\+\+E\+OF~(-\/2)}\hypertarget{group__avr__stdio_ga280c47b9edff2751b8dbb9a715dc44c5}{}\label{group__avr__stdio_ga280c47b9edff2751b8dbb9a715dc44c5}
Return code for an end-\/of-\/file condition during device read.

To be used in the get function of fdevopen(). \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR@{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR}}
\index{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR@{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{\+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR}{_FDEV_ERR}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+F\+D\+E\+V\+\_\+\+E\+RR~(-\/1)}\hypertarget{group__avr__stdio_ga132917c782a0ba854c3ae9abe57c3b12}{}\label{group__avr__stdio_ga132917c782a0ba854c3ae9abe57c3b12}
Return code for an error condition during device read.

To be used in the get function of fdevopen(). \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD}}
\index{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD}{_FDEV_SETUP_READ}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+R\+E\+AD~\+\_\+\+\_\+\+S\+RD}\hypertarget{group__avr__stdio_ga79826a1c733e4f67843256d34ad64352}{}\label{group__avr__stdio_ga79826a1c733e4f67843256d34ad64352}
fdev\+\_\+setup\+\_\+stream() with read intent \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW}}
\index{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW}{_FDEV_SETUP_RW}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+RW~(\+\_\+\+\_\+\+S\+RD$\vert$\+\_\+\+\_\+\+S\+WR)}\hypertarget{group__avr__stdio_ga93db55caeeaf13488a635f8896a6bdf3}{}\label{group__avr__stdio_ga93db55caeeaf13488a635f8896a6bdf3}
fdev\+\_\+setup\+\_\+stream() with read/write intent \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE}}
\index{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE@{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{\+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE}{_FDEV_SETUP_WRITE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define \+\_\+\+F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+W\+R\+I\+TE~\+\_\+\+\_\+\+S\+WR}\hypertarget{group__avr__stdio_ga822a791a1c06a12b95c14ace75b48ad2}{}\label{group__avr__stdio_ga822a791a1c06a12b95c14ace75b48ad2}
fdev\+\_\+setup\+\_\+stream() with write intent \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!E\+OF@{E\+OF}}
\index{E\+OF@{E\+OF}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{E\+OF}{EOF}}]{\setlength{\rightskip}{0pt plus 5cm}\#define E\+OF~(-\/1)}\hypertarget{group__avr__stdio_ga59adc4c82490d23754cd39c2fb99b0da}{}\label{group__avr__stdio_ga59adc4c82490d23754cd39c2fb99b0da}
{\ttfamily E\+OF} declares the value that is returned by various standard IO functions in case of an error. Since the A\+VR platform (currently) doesn\textquotesingle{}t contain an abstraction for actual files, its origin as \char`\"{}end of file\char`\"{} is somewhat meaningless here. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fdev\+\_\+close@{fdev\+\_\+close}}
\index{fdev\+\_\+close@{fdev\+\_\+close}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fdev\+\_\+close}{fdev_close}}]{\setlength{\rightskip}{0pt plus 5cm}\#define fdev\+\_\+close(
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)~((void)0)}\hypertarget{group__avr__stdio_gaa1226b8f734a1b5148d931ae2908c45d}{}\label{group__avr__stdio_gaa1226b8f734a1b5148d931ae2908c45d}
This macro frees up any library resources that might be associated with {\ttfamily stream}. It should be called if {\ttfamily stream} is no longer needed, right before the application is going to destroy the {\ttfamily stream} object itself.

(Currently, this macro evaluates to nothing, but this might change in future versions of the library.) \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fdev\+\_\+get\+\_\+udata@{fdev\+\_\+get\+\_\+udata}}
\index{fdev\+\_\+get\+\_\+udata@{fdev\+\_\+get\+\_\+udata}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fdev\+\_\+get\+\_\+udata}{fdev_get_udata}}]{\setlength{\rightskip}{0pt plus 5cm}\#define fdev\+\_\+get\+\_\+udata(
\begin{DoxyParamCaption}
\item[{}]{stream}
\end{DoxyParamCaption}
)~((stream)-\/$>$udata)}\hypertarget{group__avr__stdio_gac04f5faa8e86a4ce4ae084d85386af40}{}\label{group__avr__stdio_gac04f5faa8e86a4ce4ae084d85386af40}
This macro retrieves a pointer to user defined data from a F\+I\+LE stream object. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fdev\+\_\+set\+\_\+udata@{fdev\+\_\+set\+\_\+udata}}
\index{fdev\+\_\+set\+\_\+udata@{fdev\+\_\+set\+\_\+udata}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fdev\+\_\+set\+\_\+udata}{fdev_set_udata}}]{\setlength{\rightskip}{0pt plus 5cm}\#define fdev\+\_\+set\+\_\+udata(
\begin{DoxyParamCaption}
\item[{}]{stream, }
\item[{}]{u}
\end{DoxyParamCaption}
)~do \{ (stream)-\/$>$udata = u; \} while(0)}\hypertarget{group__avr__stdio_ga793fcb8f10b6b8746d4186012929ddf1}{}\label{group__avr__stdio_ga793fcb8f10b6b8746d4186012929ddf1}
This macro inserts a pointer to user defined data into a F\+I\+LE stream object.

The user data can be useful for tracking state in the put and get functions supplied to the fdevopen() function. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fdev\+\_\+setup\+\_\+stream@{fdev\+\_\+setup\+\_\+stream}}
\index{fdev\+\_\+setup\+\_\+stream@{fdev\+\_\+setup\+\_\+stream}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fdev\+\_\+setup\+\_\+stream}{fdev_setup_stream}}]{\setlength{\rightskip}{0pt plus 5cm}\#define fdev\+\_\+setup\+\_\+stream(
\begin{DoxyParamCaption}
\item[{}]{stream, }
\item[{}]{p, }
\item[{}]{g, }
\item[{}]{f}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gabc0a6f877e53d0e06583f0a91eaf5609}{}\label{group__avr__stdio_gabc0a6f877e53d0e06583f0a91eaf5609}
{\bfseries Value\+:}
\begin{DoxyCode}
\textcolor{keywordflow}{do} \{ \(\backslash\)
        (stream)->put = p; \(\backslash\)
        (stream)->\textcolor{keyword}{get} = g; \(\backslash\)
        (stream)->flags = f; \(\backslash\)
        (stream)->udata = 0; \(\backslash\)
    \} \textcolor{keywordflow}{while}(0)
\end{DoxyCode}
\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM@{F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM}}
\index{F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM@{F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM}{FDEV_SETUP_STREAM}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+AM(
\begin{DoxyParamCaption}
\item[{}]{p, }
\item[{}]{g, }
\item[{}]{f}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga3ff7af26e9e2749d48925090ff63a8f0}{}\label{group__avr__stdio_ga3ff7af26e9e2749d48925090ff63a8f0}
{\bfseries Value\+:}
\begin{DoxyCode}
\{ \(\backslash\)
        .put = p, \(\backslash\)
        .get = g, \(\backslash\)
        .flags = f, \(\backslash\)
        .udata = 0, \(\backslash\)
    \}
\end{DoxyCode}
\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!F\+I\+LE@{F\+I\+LE}}
\index{F\+I\+LE@{F\+I\+LE}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{F\+I\+LE}{FILE}}]{\setlength{\rightskip}{0pt plus 5cm}\#define F\+I\+LE~struct {\bf \+\_\+\+\_\+file}}\hypertarget{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}{}\label{group__avr__stdio_ga3e8cefeee58f762ff50bcef35fa12eec}
{\ttfamily F\+I\+LE} is the opaque structure that is passed around between the various standard IO functions. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!getc@{getc}}
\index{getc@{getc}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{getc}{getc}}]{\setlength{\rightskip}{0pt plus 5cm}\#define getc(
\begin{DoxyParamCaption}
\item[{}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)~{\bf fgetc}(\+\_\+\+\_\+stream)}\hypertarget{group__avr__stdio_gacff255b3a0079ebb1516e8a4eb23a6fb}{}\label{group__avr__stdio_gacff255b3a0079ebb1516e8a4eb23a6fb}
The macro {\ttfamily getc} used to be a \char`\"{}fast\char`\"{} macro implementation with a functionality identical to \hyperlink{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{fgetc()}. For space constraints, in {\ttfamily avr-\/libc}, it is just an alias for {\ttfamily fgetc}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!getchar@{getchar}}
\index{getchar@{getchar}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{getchar}{getchar}}]{\setlength{\rightskip}{0pt plus 5cm}int getchar(
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)~{\bf fgetc}({\bf stdin})}\hypertarget{group__avr__stdio_gac45fdeab51c3197c1e7c4ec7beabaca9}{}\label{group__avr__stdio_gac45fdeab51c3197c1e7c4ec7beabaca9}
The macro {\ttfamily getchar} reads a character from {\ttfamily stdin}. Return values and error handling is identical to \hyperlink{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{fgetc()}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!putc@{putc}}
\index{putc@{putc}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{putc}{putc}}]{\setlength{\rightskip}{0pt plus 5cm}\#define putc(
\begin{DoxyParamCaption}
\item[{}]{\+\_\+\+\_\+c, }
\item[{}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)~{\bf fputc}(\+\_\+\+\_\+c, \+\_\+\+\_\+stream)}\hypertarget{group__avr__stdio_ga247111653f3e91bf2cb4930d590d8201}{}\label{group__avr__stdio_ga247111653f3e91bf2cb4930d590d8201}
The macro {\ttfamily putc} used to be a \char`\"{}fast\char`\"{} macro implementation with a functionality identical to \hyperlink{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}{fputc()}. For space constraints, in {\ttfamily avr-\/libc}, it is just an alias for {\ttfamily fputc}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!putchar@{putchar}}
\index{putchar@{putchar}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{putchar}{putchar}}]{\setlength{\rightskip}{0pt plus 5cm}\#define putchar(
\begin{DoxyParamCaption}
\item[{}]{\+\_\+\+\_\+c}
\end{DoxyParamCaption}
)~{\bf fputc}(\+\_\+\+\_\+c, {\bf stdout})}\hypertarget{group__avr__stdio_ga61e2590ae5f2f2e351365640d2ac755a}{}\label{group__avr__stdio_ga61e2590ae5f2f2e351365640d2ac755a}
The macro {\ttfamily putchar} sends character {\ttfamily c} to {\ttfamily stdout}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!stderr@{stderr}}
\index{stderr@{stderr}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{stderr}{stderr}}]{\setlength{\rightskip}{0pt plus 5cm}\#define stderr~(\+\_\+\+\_\+iob\mbox{[}2\mbox{]})}\hypertarget{group__avr__stdio_ga5ce35bd5ba5021fd3b2e951e8f497656}{}\label{group__avr__stdio_ga5ce35bd5ba5021fd3b2e951e8f497656}
Stream destined for error output. Unless specifically assigned, identical to {\ttfamily stdout}.

If {\ttfamily stderr} should point to another stream, the result of another {\ttfamily fdevopen()} must be explicitly assigned to it without closing the previous {\ttfamily stderr} (since this would also close {\ttfamily stdout}). \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!stdin@{stdin}}
\index{stdin@{stdin}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{stdin}{stdin}}]{\setlength{\rightskip}{0pt plus 5cm}\#define stdin~(\+\_\+\+\_\+iob\mbox{[}0\mbox{]})}\hypertarget{group__avr__stdio_gaaca70138f0cb63ddb026921afc635179}{}\label{group__avr__stdio_gaaca70138f0cb63ddb026921afc635179}
Stream that will be used as an input stream by the simplified functions that don\textquotesingle{}t take a {\ttfamily stream} argument.

The first stream opened with read intent using {\ttfamily fdevopen()} will be assigned to {\ttfamily stdin}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!stdout@{stdout}}
\index{stdout@{stdout}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{stdout}{stdout}}]{\setlength{\rightskip}{0pt plus 5cm}\#define stdout~(\+\_\+\+\_\+iob\mbox{[}1\mbox{]})}\hypertarget{group__avr__stdio_ga0c0ef221f95f64e8632451312fd18cc8}{}\label{group__avr__stdio_ga0c0ef221f95f64e8632451312fd18cc8}
Stream that will be used as an output stream by the simplified functions that don\textquotesingle{}t take a {\ttfamily stream} argument.

The first stream opened with write intent using {\ttfamily fdevopen()} will be assigned to both, {\ttfamily stdin}, and {\ttfamily stderr}. 

\subsection{Function Documentation}
\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!clearerr@{clearerr}}
\index{clearerr@{clearerr}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{clearerr(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{clearerr(FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}void clearerr (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaaa6d255675688c736c99ebd32f2a7214}{}\label{group__avr__stdio_gaaa6d255675688c736c99ebd32f2a7214}
Clear the error and end-\/of-\/file flags of {\ttfamily stream}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fclose@{fclose}}
\index{fclose@{fclose}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fclose(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fclose(FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int fclose (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{}\label{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}
This function closes {\ttfamily stream}, and disallows and further IO to and from it.

When using fdevopen() to setup the stream, a call to \hyperlink{group__avr__stdio_gad3d27a6dcc225237171196dd0739bb10}{fclose()} is needed in order to free the internal resources allocated.

If the stream has been set up using fdev\+\_\+setup\+\_\+stream() or F\+D\+E\+V\+\_\+\+S\+E\+T\+U\+P\+\_\+\+S\+T\+R\+E\+A\+M(), use \hyperlink{group__avr__stdio_gaa1226b8f734a1b5148d931ae2908c45d}{fdev\+\_\+close()} instead.

It currently always returns 0 (for success). \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!feof@{feof}}
\index{feof@{feof}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{feof(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{feof(FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int feof (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga47b00053272d6443c9befdb1304002cb}{}\label{group__avr__stdio_ga47b00053272d6443c9befdb1304002cb}
Test the end-\/of-\/file flag of {\ttfamily stream}. This flag can only be cleared by a call to \hyperlink{group__avr__stdio_gaaa6d255675688c736c99ebd32f2a7214}{clearerr()}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!ferror@{ferror}}
\index{ferror@{ferror}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{ferror(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{ferror(FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int ferror (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}{}\label{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}
Test the error flag of {\ttfamily stream}. This flag can only be cleared by a call to \hyperlink{group__avr__stdio_gaaa6d255675688c736c99ebd32f2a7214}{clearerr()}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fgetc@{fgetc}}
\index{fgetc@{fgetc}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fgetc(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fgetc(FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int fgetc (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}{}\label{group__avr__stdio_ga818d63019adc9d518a13f9c36ed04f35}
The function {\ttfamily fgetc} reads a character from {\ttfamily stream}. It returns the character, or {\ttfamily E\+OF} in case end-\/of-\/file was encountered or an error occurred. The routines \hyperlink{group__avr__stdio_ga47b00053272d6443c9befdb1304002cb}{feof()} or \hyperlink{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}{ferror()} must be used to distinguish between both situations. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fgets@{fgets}}
\index{fgets@{fgets}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fgets(char $\ast$\+\_\+\+\_\+str, int \+\_\+\+\_\+size, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fgets(char *__str, int __size, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ fgets (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+str, }
\item[{int}]{\+\_\+\+\_\+size, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga00d34a8bff0293d2d6f4563d248d8fb2}{}\label{group__avr__stdio_ga00d34a8bff0293d2d6f4563d248d8fb2}
Read at most {\ttfamily size -\/ 1} bytes from {\ttfamily stream}, until a newline character was encountered, and store the characters in the buffer pointed to by {\ttfamily str}. Unless an error was encountered while reading, the string will then be terminated with a {\ttfamily N\+UL} character.

If an error was encountered, the function returns N\+U\+LL and sets the error flag of {\ttfamily stream}, which can be tested using \hyperlink{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}{ferror()}. Otherwise, a pointer to the string will be returned. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fprintf@{fprintf}}
\index{fprintf@{fprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fprintf(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)}{fprintf(FILE *__stream, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int fprintf (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga0e41285401c397eb29692205a95fcd9c}{}\label{group__avr__stdio_ga0e41285401c397eb29692205a95fcd9c}
The function {\ttfamily fprintf} performs formatted output to {\ttfamily stream}. See {\ttfamily \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()}} for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fprintf\+\_\+P@{fprintf\+\_\+P}}
\index{fprintf\+\_\+P@{fprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fprintf\+\_\+\+P(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)}{fprintf_P(FILE *__stream, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int fprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga36173b4a8551b61811089198beec69d9}{}\label{group__avr__stdio_ga36173b4a8551b61811089198beec69d9}
Variant of {\ttfamily \hyperlink{group__avr__stdio_ga0e41285401c397eb29692205a95fcd9c}{fprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fputc@{fputc}}
\index{fputc@{fputc}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fputc(int \+\_\+\+\_\+c, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fputc(int __c, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int fputc (
\begin{DoxyParamCaption}
\item[{int}]{\+\_\+\+\_\+c, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}{}\label{group__avr__stdio_gaf3387285b3eb0ce4e0e7ca3ccaed9014}
The function {\ttfamily fputc} sends the character {\ttfamily c} (though given as type {\ttfamily int}) to {\ttfamily stream}. It returns the character, or {\ttfamily E\+OF} in case an error occurred. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fputs@{fputs}}
\index{fputs@{fputs}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fputs(const char $\ast$\+\_\+\+\_\+str, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fputs(const char *__str, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int fputs (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+str, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga19c2bbe9ce4af9f0a7e3448387004fd3}{}\label{group__avr__stdio_ga19c2bbe9ce4af9f0a7e3448387004fd3}
Write the string pointed to by {\ttfamily str} to stream {\ttfamily stream}.

Returns 0 on success and E\+OF on error. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fputs\+\_\+P@{fputs\+\_\+P}}
\index{fputs\+\_\+P@{fputs\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fputs\+\_\+\+P(const char $\ast$\+\_\+\+\_\+str, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fputs_P(const char *__str, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int fputs\+\_\+P (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+str, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga3d25813cb225ca410518a3f48eb00caa}{}\label{group__avr__stdio_ga3d25813cb225ca410518a3f48eb00caa}
Variant of \hyperlink{group__avr__stdio_ga19c2bbe9ce4af9f0a7e3448387004fd3}{fputs()} where {\ttfamily str} resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fread@{fread}}
\index{fread@{fread}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fread(void $\ast$\+\_\+\+\_\+ptr, size\+\_\+t \+\_\+\+\_\+size, size\+\_\+t \+\_\+\+\_\+nmemb, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fread(void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t fread (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{\+\_\+\+\_\+ptr, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+size, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+nmemb, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga54fa47156a34c1659a29ed96e46e3518}{}\label{group__avr__stdio_ga54fa47156a34c1659a29ed96e46e3518}
Read {\ttfamily nmemb} objects, {\ttfamily size} bytes each, from {\ttfamily stream}, to the buffer pointed to by {\ttfamily ptr}.

Returns the number of objects successfully read, i. e. {\ttfamily nmemb} unless an input error occured or end-\/of-\/file was encountered. \hyperlink{group__avr__stdio_ga47b00053272d6443c9befdb1304002cb}{feof()} and \hyperlink{group__avr__stdio_gaa89248dd55efb5f59a96e82976c97758}{ferror()} must be used to distinguish between these two conditions. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fscanf@{fscanf}}
\index{fscanf@{fscanf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fscanf(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)}{fscanf(FILE *__stream, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int fscanf (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga0beb4fd9ff6833a364e3ce60370de058}{}\label{group__avr__stdio_ga0beb4fd9ff6833a364e3ce60370de058}
The function {\ttfamily fscanf} performs formatted input, reading the input data from {\ttfamily stream}.

See vfscanf() for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fscanf\+\_\+P@{fscanf\+\_\+P}}
\index{fscanf\+\_\+P@{fscanf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fscanf\+\_\+\+P(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt,...)}{fscanf_P(FILE *__stream, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int fscanf\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga7aec94e711ad64724076666586a26839}{}\label{group__avr__stdio_ga7aec94e711ad64724076666586a26839}
Variant of \hyperlink{group__avr__stdio_ga0beb4fd9ff6833a364e3ce60370de058}{fscanf()} using a {\ttfamily fmt} string in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!fwrite@{fwrite}}
\index{fwrite@{fwrite}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{fwrite(const void $\ast$\+\_\+\+\_\+ptr, size\+\_\+t \+\_\+\+\_\+size, size\+\_\+t \+\_\+\+\_\+nmemb, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{fwrite(const void *__ptr, size_t __size, size_t __nmemb, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t fwrite (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{\+\_\+\+\_\+ptr, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+size, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+nmemb, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gadd5777719a41713629a62b68c239a774}{}\label{group__avr__stdio_gadd5777719a41713629a62b68c239a774}
Write {\ttfamily nmemb} objects, {\ttfamily size} bytes each, to {\ttfamily stream}. The first byte of the first object is referenced by {\ttfamily ptr}.

Returns the number of objects successfully written, i. e. {\ttfamily nmemb} unless an output error occured. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!gets@{gets}}
\index{gets@{gets}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{gets(char $\ast$\+\_\+\+\_\+str)}{gets(char *__str)}}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ gets (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+str}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaf577dcba9afe50a9d068d0b69ac85d2f}{}\label{group__avr__stdio_gaf577dcba9afe50a9d068d0b69ac85d2f}
Similar to \hyperlink{group__avr__stdio_ga00d34a8bff0293d2d6f4563d248d8fb2}{fgets()} except that it will operate on stream {\ttfamily stdin}, and the trailing newline (if any) will not be stored in the string. It is the caller\textquotesingle{}s responsibility to provide enough storage to hold the characters read. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!printf@{printf}}
\index{printf@{printf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{printf(const char $\ast$\+\_\+\+\_\+fmt,...)}{printf(const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int printf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{}\label{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}
The function {\ttfamily printf} performs formatted output to stream {\ttfamily stdout}. See {\ttfamily \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()}} for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!printf\+\_\+P@{printf\+\_\+P}}
\index{printf\+\_\+P@{printf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{printf\+\_\+\+P(const char $\ast$\+\_\+\+\_\+fmt,...)}{printf_P(const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int printf\+\_\+P (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga418e63921ed6259e873cd21b6c5c8e6e}{}\label{group__avr__stdio_ga418e63921ed6259e873cd21b6c5c8e6e}
Variant of {\ttfamily \hyperlink{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{printf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!puts@{puts}}
\index{puts@{puts}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{puts(const char $\ast$\+\_\+\+\_\+str)}{puts(const char *__str)}}]{\setlength{\rightskip}{0pt plus 5cm}int puts (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+str}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga33f7bd99d40bf6f68a00d5507d65363d}{}\label{group__avr__stdio_ga33f7bd99d40bf6f68a00d5507d65363d}
Write the string pointed to by {\ttfamily str}, and a trailing newline character, to {\ttfamily stdout}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!puts\+\_\+P@{puts\+\_\+P}}
\index{puts\+\_\+P@{puts\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{puts\+\_\+\+P(const char $\ast$\+\_\+\+\_\+str)}{puts_P(const char *__str)}}]{\setlength{\rightskip}{0pt plus 5cm}int puts\+\_\+P (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+str}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gab4de83c560c79bf880fa39b997d61610}{}\label{group__avr__stdio_gab4de83c560c79bf880fa39b997d61610}
Variant of \hyperlink{group__avr__stdio_ga33f7bd99d40bf6f68a00d5507d65363d}{puts()} where {\ttfamily str} resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!scanf@{scanf}}
\index{scanf@{scanf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{scanf(const char $\ast$\+\_\+\+\_\+fmt,...)}{scanf(const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int scanf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga3f0edc16dcabb5344d59d42cf7682102}{}\label{group__avr__stdio_ga3f0edc16dcabb5344d59d42cf7682102}
The function {\ttfamily scanf} performs formatted input from stream {\ttfamily stdin}.

See vfscanf() for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!scanf\+\_\+P@{scanf\+\_\+P}}
\index{scanf\+\_\+P@{scanf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{scanf\+\_\+\+P(const char $\ast$\+\_\+\+\_\+fmt,...)}{scanf_P(const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int scanf\+\_\+P (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga0fb7fd70cd7618f27d8219c97e61bcf3}{}\label{group__avr__stdio_ga0fb7fd70cd7618f27d8219c97e61bcf3}
Variant of \hyperlink{group__avr__stdio_ga3f0edc16dcabb5344d59d42cf7682102}{scanf()} where {\ttfamily fmt} resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!snprintf@{snprintf}}
\index{snprintf@{snprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{snprintf(char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt,...)}{snprintf(char *__s, size_t __n, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int snprintf (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+n, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga77070c245d4ca4f7ec7d7144260fb875}{}\label{group__avr__stdio_ga77070c245d4ca4f7ec7d7144260fb875}
Like {\ttfamily \hyperlink{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}{sprintf()}}, but instead of assuming {\ttfamily s} to be of infinite size, no more than {\ttfamily n} characters (including the trailing N\+UL character) will be converted to {\ttfamily s}.

Returns the number of characters that would have been written to {\ttfamily s} if there were enough space. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!snprintf\+\_\+P@{snprintf\+\_\+P}}
\index{snprintf\+\_\+P@{snprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{snprintf\+\_\+\+P(char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt,...)}{snprintf_P(char *__s, size_t __n, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int snprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+n, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga53ff61856759709eeceae10aaa10a0a3}{}\label{group__avr__stdio_ga53ff61856759709eeceae10aaa10a0a3}
Variant of {\ttfamily \hyperlink{group__avr__stdio_ga77070c245d4ca4f7ec7d7144260fb875}{snprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!sprintf@{sprintf}}
\index{sprintf@{sprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{sprintf(char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt,...)}{sprintf(char *__s, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int sprintf (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}{}\label{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}
Variant of {\ttfamily \hyperlink{group__avr__stdio_ga4c04da4953607fa5fa4d3908fecde449}{printf()}} that sends the formatted characters to string {\ttfamily s}. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!sprintf\+\_\+P@{sprintf\+\_\+P}}
\index{sprintf\+\_\+P@{sprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{sprintf\+\_\+\+P(char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt,...)}{sprintf_P(char *__s, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int sprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga2b829d696b17dedbf181cd5dc4d7a31d}{}\label{group__avr__stdio_ga2b829d696b17dedbf181cd5dc4d7a31d}
Variant of {\ttfamily \hyperlink{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}{sprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!sscanf@{sscanf}}
\index{sscanf@{sscanf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{sscanf(const char $\ast$\+\_\+\+\_\+buf, const char $\ast$\+\_\+\+\_\+fmt,...)}{sscanf(const char *__buf, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int sscanf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+buf, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga5507d0e1bbfd387fbb2ffcfd8f5dca6f}{}\label{group__avr__stdio_ga5507d0e1bbfd387fbb2ffcfd8f5dca6f}
The function {\ttfamily sscanf} performs formatted input, reading the input data from the buffer pointed to by {\ttfamily buf}.

See vfscanf() for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!sscanf\+\_\+P@{sscanf\+\_\+P}}
\index{sscanf\+\_\+P@{sscanf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{sscanf\+\_\+\+P(const char $\ast$\+\_\+\+\_\+buf, const char $\ast$\+\_\+\+\_\+fmt,...)}{sscanf_P(const char *__buf, const char *__fmt,...)}}]{\setlength{\rightskip}{0pt plus 5cm}int sscanf\+\_\+P (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+buf, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{}]{...}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaeca11dc4b3757ed4ff2f2a4950eba117}{}\label{group__avr__stdio_gaeca11dc4b3757ed4ff2f2a4950eba117}
Variant of \hyperlink{group__avr__stdio_ga5507d0e1bbfd387fbb2ffcfd8f5dca6f}{sscanf()} using a {\ttfamily fmt} string in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!ungetc@{ungetc}}
\index{ungetc@{ungetc}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{ungetc(int \+\_\+\+\_\+c, F\+I\+L\+E $\ast$\+\_\+\+\_\+stream)}{ungetc(int __c, FILE *__stream)}}]{\setlength{\rightskip}{0pt plus 5cm}int ungetc (
\begin{DoxyParamCaption}
\item[{int}]{\+\_\+\+\_\+c, }
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gab4f9b130166e5811519513d6178c1ae3}{}\label{group__avr__stdio_gab4f9b130166e5811519513d6178c1ae3}
The \hyperlink{group__avr__stdio_gab4f9b130166e5811519513d6178c1ae3}{ungetc()} function pushes the character {\ttfamily c} (converted to an unsigned char) back onto the input stream pointed to by {\ttfamily stream}. The pushed-\/back character will be returned by a subsequent read on the stream.

Currently, only a single character can be pushed back onto the stream.

The \hyperlink{group__avr__stdio_gab4f9b130166e5811519513d6178c1ae3}{ungetc()} function returns the character pushed back after the conversion, or {\ttfamily E\+OF} if the operation fails. If the value of the argument {\ttfamily c} character equals {\ttfamily E\+OF}, the operation will fail and the stream will remain unchanged. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vfprintf@{vfprintf}}
\index{vfprintf@{vfprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vfprintf(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)}{vfprintf(FILE *__stream, const char *__fmt, va_list __ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vfprintf (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{\+\_\+\+\_\+ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{}\label{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}
{\ttfamily vfprintf} is the central facility of the {\ttfamily printf} family of functions. It outputs values to {\ttfamily stream} under control of a format string passed in {\ttfamily fmt}. The actual values to print are passed as a variable argument list {\ttfamily ap}.

{\ttfamily vfprintf} returns the number of characters written to {\ttfamily stream}, or {\ttfamily E\+OF} in case of an error. Currently, this will only happen if {\ttfamily stream} has not been opened with write intent.

The format string is composed of zero or more directives\+: ordinary characters (not {\ttfamily \%}), which are copied unchanged to the output stream; and conversion specifications, each of which results in fetching zero or more subsequent arguments. Each conversion specification is introduced by the {\ttfamily \%} character. The arguments must properly correspond (after type promotion) with the conversion specifier. After the {\ttfamily \%}, the following appear in sequence\+:


\begin{DoxyItemize}
\item Zero or more of the following flags\+: 
\begin{DoxyItemize}
\item {\ttfamily \#} The value should be converted to an \char`\"{}alternate form\char`\"{}. For c, d, i, s, and u conversions, this option has no effect. For o conversions, the precision of the number is increased to force the first character of the output string to a zero (except if a zero value is printed with an explicit precision of zero). For x and X conversions, a non-\/zero result has the string `0x\textquotesingle{} (or `0X\textquotesingle{} for X conversions) prepended to it. 
\item {\ttfamily 0} (zero) Zero padding. For all conversions, the converted value is padded on the left with zeros rather than blanks. If a precision is given with a numeric conversion (d, i, o, u, i, x, and X), the 0 flag is ignored. 
\item {\ttfamily -\/} A negative field width flag; the converted value is to be left adjusted on the field boundary. The converted value is padded on the right with blanks, rather than on the left with blanks or zeros. A -\/ overrides a 0 if both are given. 
\item \textquotesingle{} \textquotesingle{} (space) A blank should be left before a positive number produced by a signed conversion (d, or i). 
\item {\ttfamily +} A sign must always be placed before a number produced by a signed conversion. A + overrides a space if both are used. 
\end{DoxyItemize}
\item An optional decimal digit string specifying a minimum field width. If the converted value has fewer characters than the field width, it will be padded with spaces on the left (or right, if the left-\/adjustment flag has been given) to fill out the field width.
\item An optional precision, in the form of a period . followed by an optional digit string. If the digit string is omitted, the precision is taken as zero. This gives the minimum number of digits to appear for d, i, o, u, x, and X conversions, or the maximum number of characters to be printed from a string for {\ttfamily s} conversions.
\item An optional {\ttfamily l} or {\ttfamily h} length modifier, that specifies that the argument for the d, i, o, u, x, or X conversion is a {\ttfamily \char`\"{}long int\char`\"{}} rather than {\ttfamily int}. The {\ttfamily h} is ignored, as {\ttfamily \char`\"{}short int\char`\"{}} is equivalent to {\ttfamily int}.
\item A character that specifies the type of conversion to be applied.
\end{DoxyItemize}

The conversion specifiers and their meanings are\+:


\begin{DoxyItemize}
\item {\ttfamily diouxX} The int (or appropriate variant) argument is converted to signed decimal (d and i), unsigned octal (o), unsigned decimal (u), or unsigned hexadecimal (x and X) notation. The letters \char`\"{}abcdef\char`\"{} are used for x conversions; the letters \char`\"{}\+A\+B\+C\+D\+E\+F\char`\"{} are used for X conversions. The precision, if any, gives the minimum number of digits that must appear; if the converted value requires fewer digits, it is padded on the left with zeros.
\item {\ttfamily p} The {\ttfamily void $\ast$} argument is taken as an unsigned integer, and converted similarly as a {\ttfamily \%\#x} command would do.
\item {\ttfamily c} The {\ttfamily int} argument is converted to an {\ttfamily \char`\"{}unsigned char\char`\"{}}, and the resulting character is written.
\item {\ttfamily s} The {\ttfamily \char`\"{}char $\ast$\char`\"{}} argument is expected to be a pointer to an array of character type (pointer to a string). Characters from the array are written up to (but not including) a terminating N\+UL character; if a precision is specified, no more than the number specified are written. If a precision is given, no null character need be present; if the precision is not specified, or is greater than the size of the array, the array must contain a terminating N\+UL character.
\item {\ttfamily \%} A {\ttfamily \%} is written. No argument is converted. The complete conversion specification is \char`\"{}\%\%\char`\"{}.
\item {\ttfamily eE} The double argument is rounded and converted in the format {\ttfamily \char`\"{}\mbox{[}-\/\mbox{]}d.\+dddedd\char`\"{}} where there is one digit before the decimal-\/point character and the number of digits after it is equal to the precision; if the precision is missing, it is taken as 6; if the precision is zero, no decimal-\/point character appears. An {\itshape E} conversion uses the letter {\ttfamily \textquotesingle{}E\textquotesingle{}} (rather than {\ttfamily \textquotesingle{}e\textquotesingle{}}) to introduce the exponent. The exponent always contains two digits; if the value is zero, the exponent is 00.
\item {\ttfamily fF} The double argument is rounded and converted to decimal notation in the format {\ttfamily \char`\"{}\mbox{[}-\/\mbox{]}ddd.\+ddd\char`\"{}}, where the number of digits after the decimal-\/point character is equal to the precision specification. If the precision is missing, it is taken as 6; if the precision is explicitly zero, no decimal-\/point character appears. If a decimal point appears, at least one digit appears before it.
\item {\ttfamily gG} The double argument is converted in style {\ttfamily f} or {\ttfamily e} (or {\ttfamily F} or {\ttfamily E} for {\ttfamily G} conversions). The precision specifies the number of significant digits. If the precision is missing, 6 digits are given; if the precision is zero, it is treated as 1. Style {\ttfamily e} is used if the exponent from its conversion is less than -\/4 or greater than or equal to the precision. Trailing zeros are removed from the fractional part of the result; a decimal point appears only if it is followed by at least one digit.
\item {\ttfamily S} Similar to the {\ttfamily s} format, except the pointer is expected to point to a program-\/memory (R\+OM) string instead of a R\+AM string.
\end{DoxyItemize}

In no case does a non-\/existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.

Since the full implementation of all the mentioned features becomes fairly large, three different flavours of \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} can be selected using linker options. The default \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} implements all the mentioned functionality except floating point conversions. A minimized version of \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} is available that only implements the very basic integer and string conversion facilities, but only the {\ttfamily \#} additional option can be specified using conversion flags (these flags are parsed correctly from the format specification, but then simply ignored). This version can be requested using the following compiler options\+:


\begin{DoxyCode}
1 -Wl,-u,vfprintf -lprintf\_min
\end{DoxyCode}


If the full functionality including the floating point conversions is required, the following options should be used\+:


\begin{DoxyCode}
1 -Wl,-u,vfprintf -lprintf\_flt -lm
\end{DoxyCode}


\begin{DoxyParagraph}{Limitations\+:}

\begin{DoxyItemize}
\item The specified width and precision can be at most 255.
\end{DoxyItemize}
\end{DoxyParagraph}
\begin{DoxyParagraph}{Notes\+:}

\begin{DoxyItemize}
\item For floating-\/point conversions, if you link default or minimized version of \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()}, the symbol {\ttfamily }? will be output and double argument will be skiped. So you output below will not be crashed. For default version the width field and the \char`\"{}pad to left\char`\"{} ( symbol minus ) option will work in this case.
\item The {\ttfamily hh} length modifier is ignored ({\ttfamily char} argument is promouted to {\ttfamily int}). More exactly, this realization does not check the number of {\ttfamily h} symbols.
\item But the {\ttfamily ll} length modifier will to abort the output, as this realization does not operate {\ttfamily long} {\ttfamily long} arguments.
\item The variable width or precision field (an asterisk {\ttfamily $\ast$} symbol) is not realized and will to abort the output. 
\end{DoxyItemize}
\end{DoxyParagraph}
\index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vfprintf\+\_\+P@{vfprintf\+\_\+P}}
\index{vfprintf\+\_\+P@{vfprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vfprintf\+\_\+\+P(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)}{vfprintf_P(FILE *__stream, const char *__fmt, va_list __ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vfprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{\+\_\+\+\_\+ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga55b25ecbfd3811ea4495d1f235e2e186}{}\label{group__avr__stdio_ga55b25ecbfd3811ea4495d1f235e2e186}
Variant of {\ttfamily \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vfscanf\+\_\+P@{vfscanf\+\_\+P}}
\index{vfscanf\+\_\+P@{vfscanf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vfscanf\+\_\+\+P(\+F\+I\+L\+E $\ast$\+\_\+\+\_\+stream, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)}{vfscanf_P(FILE *__stream, const char *__fmt, va_list __ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vfscanf\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf F\+I\+LE} $\ast$}]{\+\_\+\+\_\+stream, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{\+\_\+\+\_\+ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga6c6b5b881ce8f4739777ff3a615e988a}{}\label{group__avr__stdio_ga6c6b5b881ce8f4739777ff3a615e988a}
Variant of vfscanf() using a {\ttfamily fmt} string in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vprintf@{vprintf}}
\index{vprintf@{vprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vprintf(const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)}{vprintf(const char *__fmt, va_list __ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vprintf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{\+\_\+\+\_\+ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga0b15be24dd9db93355e1f62937fdfd9a}{}\label{group__avr__stdio_ga0b15be24dd9db93355e1f62937fdfd9a}
The function {\ttfamily vprintf} performs formatted output to stream {\ttfamily stdout}, taking a variable argument list as in \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()}.

See \hyperlink{group__avr__stdio_gaa3b98c0d17b35642c0f3e4649092b9f1}{vfprintf()} for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vscanf@{vscanf}}
\index{vscanf@{vscanf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vscanf(const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list \+\_\+\+\_\+ap)}{vscanf(const char *__fmt, va_list __ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vscanf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{\+\_\+\+\_\+ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga8bd4b760f67791a54e73111734caa82f}{}\label{group__avr__stdio_ga8bd4b760f67791a54e73111734caa82f}
The function {\ttfamily vscanf} performs formatted input from stream {\ttfamily stdin}, taking a variable argument list as in vfscanf().

See vfscanf() for details. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vsnprintf@{vsnprintf}}
\index{vsnprintf@{vsnprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vsnprintf(char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)}{vsnprintf(char *__s, size_t __n, const char *__fmt, va_list ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vsnprintf (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+n, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gac92e8c42a044c8f50aad5c2c69e638e0}{}\label{group__avr__stdio_gac92e8c42a044c8f50aad5c2c69e638e0}
Like {\ttfamily \hyperlink{group__avr__stdio_gaaeb1bbe21a1b9b50b207ab059a67993f}{vsprintf()}}, but instead of assuming {\ttfamily s} to be of infinite size, no more than {\ttfamily n} characters (including the trailing N\+UL character) will be converted to {\ttfamily s}.

Returns the number of characters that would have been written to {\ttfamily s} if there were enough space. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vsnprintf\+\_\+P@{vsnprintf\+\_\+P}}
\index{vsnprintf\+\_\+P@{vsnprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vsnprintf\+\_\+\+P(char $\ast$\+\_\+\+\_\+s, size\+\_\+t \+\_\+\+\_\+n, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)}{vsnprintf_P(char *__s, size_t __n, const char *__fmt, va_list ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vsnprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{size\+\_\+t}]{\+\_\+\+\_\+n, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_ga2071feb5c92bf50a6bd508a07ead9515}{}\label{group__avr__stdio_ga2071feb5c92bf50a6bd508a07ead9515}
Variant of {\ttfamily \hyperlink{group__avr__stdio_gac92e8c42a044c8f50aad5c2c69e638e0}{vsnprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vsprintf@{vsprintf}}
\index{vsprintf@{vsprintf}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vsprintf(char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)}{vsprintf(char *__s, const char *__fmt, va_list ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vsprintf (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaaeb1bbe21a1b9b50b207ab059a67993f}{}\label{group__avr__stdio_gaaeb1bbe21a1b9b50b207ab059a67993f}
Like {\ttfamily \hyperlink{group__avr__stdio_ga6017094d9fd800fa02600d35399f2a2a}{sprintf()}} but takes a variable argument list for the arguments. \index{$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}!vsprintf\+\_\+P@{vsprintf\+\_\+P}}
\index{vsprintf\+\_\+P@{vsprintf\+\_\+P}!$<$stdio.\+h$>$\+: Standard I\+O facilities@{$<$stdio.\+h$>$\+: Standard I\+O facilities}}
\subsubsection[{\texorpdfstring{vsprintf\+\_\+\+P(char $\ast$\+\_\+\+\_\+s, const char $\ast$\+\_\+\+\_\+fmt, va\+\_\+list ap)}{vsprintf_P(char *__s, const char *__fmt, va_list ap)}}]{\setlength{\rightskip}{0pt plus 5cm}int vsprintf\+\_\+P (
\begin{DoxyParamCaption}
\item[{char $\ast$}]{\+\_\+\+\_\+s, }
\item[{const char $\ast$}]{\+\_\+\+\_\+fmt, }
\item[{va\+\_\+list}]{ap}
\end{DoxyParamCaption}
)}\hypertarget{group__avr__stdio_gaf47f5141509d1e434f9da2b27287a707}{}\label{group__avr__stdio_gaf47f5141509d1e434f9da2b27287a707}
Variant of {\ttfamily \hyperlink{group__avr__stdio_gaaeb1bbe21a1b9b50b207ab059a67993f}{vsprintf()}} that uses a {\ttfamily fmt} string that resides in program memory. 