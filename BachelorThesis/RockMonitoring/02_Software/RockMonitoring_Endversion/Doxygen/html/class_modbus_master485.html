<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: ModbusMaster485 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_modbus_master485-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ModbusMaster485 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_modbus_master485_8h_source.html">ModbusMaster485.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3dbd315a6e62987c587d8cdadd1abfc2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a3dbd315a6e62987c587d8cdadd1abfc2">ModbusMaster485</a> ()</td></tr>
<tr class="separator:a3dbd315a6e62987c587d8cdadd1abfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d261601a1f5f6b54d05641531a3fde"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04d261601a1f5f6b54d05641531a3fde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>ModbusMaster485</b> (uint8_t)</td></tr>
<tr class="separator:a04d261601a1f5f6b54d05641531a3fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2abc8616c7c87d86f882a5d10fd307"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a9b2abc8616c7c87d86f882a5d10fd307">begin</a> ()</td></tr>
<tr class="separator:a9b2abc8616c7c87d86f882a5d10fd307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9f24d78b3014950b98a062a6d1b0ab"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb9f24d78b3014950b98a062a6d1b0ab"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> (unsigned long)</td></tr>
<tr class="separator:aeb9f24d78b3014950b98a062a6d1b0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139739234cf9199546781d43a6d4ed6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a139739234cf9199546781d43a6d4ed6f">idle</a> (void(*)())</td></tr>
<tr class="separator:a139739234cf9199546781d43a6d4ed6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d677f6eccd79b431444ce07f7ca10f"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a01d677f6eccd79b431444ce07f7ca10f">getResponseBuffer</a> (uint8_t)</td></tr>
<tr class="separator:a01d677f6eccd79b431444ce07f7ca10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5428ccaaa7d790a5fd10c585429c841f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a5428ccaaa7d790a5fd10c585429c841f">clearResponseBuffer</a> ()</td></tr>
<tr class="separator:a5428ccaaa7d790a5fd10c585429c841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471792408d5d0d77011ad4e5c7229b03"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a471792408d5d0d77011ad4e5c7229b03">setTransmitBuffer</a> (uint8_t, uint16_t)</td></tr>
<tr class="separator:a471792408d5d0d77011ad4e5c7229b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1957373b3f6da34f5821ed1db4b8b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#aa1957373b3f6da34f5821ed1db4b8b20">clearTransmitBuffer</a> ()</td></tr>
<tr class="separator:aa1957373b3f6da34f5821ed1db4b8b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c4a53e4b79a68e626e1b9b68d35428"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab3c4a53e4b79a68e626e1b9b68d35428"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>beginTransmission</b> (uint16_t)</td></tr>
<tr class="separator:ab3c4a53e4b79a68e626e1b9b68d35428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfa3ebb2117b1573c692cb51fdb0743"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcfa3ebb2117b1573c692cb51fdb0743"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>requestFrom</b> (uint16_t, uint16_t)</td></tr>
<tr class="separator:afcfa3ebb2117b1573c692cb51fdb0743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1fba2728a3aae96987915185d0be6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb1fba2728a3aae96987915185d0be6e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sendBit</b> (bool)</td></tr>
<tr class="separator:aeb1fba2728a3aae96987915185d0be6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d0c3be974398ff5cec63fd745ad4d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a25d0c3be974398ff5cec63fd745ad4d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>send</b> (uint8_t)</td></tr>
<tr class="separator:a25d0c3be974398ff5cec63fd745ad4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18007200504433fa4bbfa19fe2ccee5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae18007200504433fa4bbfa19fe2ccee5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>send</b> (uint16_t)</td></tr>
<tr class="separator:ae18007200504433fa4bbfa19fe2ccee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f606bdb7709d59c735bcbedebe9624a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f606bdb7709d59c735bcbedebe9624a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>send</b> (uint32_t)</td></tr>
<tr class="separator:a1f606bdb7709d59c735bcbedebe9624a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3ba1359d836695d91c3992810b1b5f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aaa3ba1359d836695d91c3992810b1b5f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSlaveAddress</b> (uint8_t)</td></tr>
<tr class="separator:aaa3ba1359d836695d91c3992810b1b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91975f3b67594179dac50a29b5fc80f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a91975f3b67594179dac50a29b5fc80f4"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>available</b> (void)</td></tr>
<tr class="separator:a91975f3b67594179dac50a29b5fc80f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc337ccfd2b903fce6c2f6442fe1679e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc337ccfd2b903fce6c2f6442fe1679e"></a>
uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>receive</b> (void)</td></tr>
<tr class="separator:adc337ccfd2b903fce6c2f6442fe1679e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cca56a5d9dd46229dc87ce172e9a9e"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a06cca56a5d9dd46229dc87ce172e9a9e">readCoils</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:a06cca56a5d9dd46229dc87ce172e9a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb777ac7541ede98f681adbd01434553"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#acb777ac7541ede98f681adbd01434553">readDiscreteInputs</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:acb777ac7541ede98f681adbd01434553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc381f1ada07bbd13a265bdb06bb34f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#afdc381f1ada07bbd13a265bdb06bb34f">readHoldingRegisters</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:afdc381f1ada07bbd13a265bdb06bb34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9083f52d2a0a15489e3e6e4ec2458002"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a9083f52d2a0a15489e3e6e4ec2458002">readInputRegisters</a> (uint16_t, uint8_t)</td></tr>
<tr class="separator:a9083f52d2a0a15489e3e6e4ec2458002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bdb4cd84a5e0a09d4250d221ad0795"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a03bdb4cd84a5e0a09d4250d221ad0795">writeSingleCoil</a> (uint16_t, uint8_t)</td></tr>
<tr class="separator:a03bdb4cd84a5e0a09d4250d221ad0795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c8f0ba40f2c16b33a6f84a6538bcc8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a86c8f0ba40f2c16b33a6f84a6538bcc8">writeSingleRegister</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:a86c8f0ba40f2c16b33a6f84a6538bcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e2e723b0627d4c9aefb9b727c7c23b3"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a9e2e723b0627d4c9aefb9b727c7c23b3">writeMultipleCoils</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:a9e2e723b0627d4c9aefb9b727c7c23b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b9b4df0d7bb799cabdb01a4936b565"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac7b9b4df0d7bb799cabdb01a4936b565"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeMultipleCoils</b> ()</td></tr>
<tr class="separator:ac7b9b4df0d7bb799cabdb01a4936b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac099952a39d535c810a9216bfbb3486a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#ac099952a39d535c810a9216bfbb3486a">writeMultipleRegisters</a> (uint16_t, uint16_t)</td></tr>
<tr class="separator:ac099952a39d535c810a9216bfbb3486a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37151164bc32116f69394d78cb376f4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa37151164bc32116f69394d78cb376f4"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>writeMultipleRegisters</b> ()</td></tr>
<tr class="separator:aa37151164bc32116f69394d78cb376f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5945a5c60765f44b64a610e8dadea85"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#ab5945a5c60765f44b64a610e8dadea85">maskWriteRegister</a> (uint16_t, uint16_t, uint16_t)</td></tr>
<tr class="separator:ab5945a5c60765f44b64a610e8dadea85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f8118287f05c7db94a5084baade945"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a27f8118287f05c7db94a5084baade945">readWriteMultipleRegisters</a> (uint16_t, uint16_t, uint16_t, uint16_t)</td></tr>
<tr class="separator:a27f8118287f05c7db94a5084baade945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18cc28722522b67eec9a920452ccc364"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18cc28722522b67eec9a920452ccc364"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>readWriteMultipleRegisters</b> (uint16_t, uint16_t)</td></tr>
<tr class="separator:a18cc28722522b67eec9a920452ccc364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9256623255409b33851d79538762c3c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#ae9256623255409b33851d79538762c3c">readRegiters</a> (uint16_t, uint16_t, uint8_t)</td></tr>
<tr class="separator:ae9256623255409b33851d79538762c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7057a8d96e13d4aef825efb4598f08c1"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a7057a8d96e13d4aef825efb4598f08c1">ku8MBIllegalFunction</a> = 0x01</td></tr>
<tr class="separator:a7057a8d96e13d4aef825efb4598f08c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e16e9a1819d2fb46f3a3e03021da02"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#ab8e16e9a1819d2fb46f3a3e03021da02">ku8MBIllegalDataAddress</a> = 0x02</td></tr>
<tr class="separator:ab8e16e9a1819d2fb46f3a3e03021da02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393b0b7ea005a15cb3d88bad75bdcdf2"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a393b0b7ea005a15cb3d88bad75bdcdf2">ku8MBIllegalDataValue</a> = 0x03</td></tr>
<tr class="separator:a393b0b7ea005a15cb3d88bad75bdcdf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7c2882e4cfd65b9eac00ba1f5d1f23"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#aca7c2882e4cfd65b9eac00ba1f5d1f23">ku8MBSlaveDeviceFailure</a> = 0x04</td></tr>
<tr class="separator:aca7c2882e4cfd65b9eac00ba1f5d1f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf669f82295bd503124df2420d6269a"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a4cf669f82295bd503124df2420d6269a">ku8MBSuccess</a> = 0x00</td></tr>
<tr class="separator:a4cf669f82295bd503124df2420d6269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6645d913b0149ebb97ecba35d0a99d"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a8c6645d913b0149ebb97ecba35d0a99d">ku8MBInvalidSlaveID</a> = 0xE0</td></tr>
<tr class="separator:a8c6645d913b0149ebb97ecba35d0a99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cef4e3625e700c5893a6f2566740d20"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a0cef4e3625e700c5893a6f2566740d20">ku8MBInvalidFunction</a> = 0xE1</td></tr>
<tr class="separator:a0cef4e3625e700c5893a6f2566740d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a3978380bf0be30685dc082452a13f"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a16a3978380bf0be30685dc082452a13f">ku8MBResponseTimedOut</a> = 0xE2</td></tr>
<tr class="separator:a16a3978380bf0be30685dc082452a13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b903c24f9893f0f3cd045e1d0b6cdeb"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_modbus_master485.html#a4b903c24f9893f0f3cd045e1d0b6cdeb">ku8MBInvalidCRC</a> = 0xE3</td></tr>
<tr class="separator:a4b903c24f9893f0f3cd045e1d0b6cdeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Waspmote class library for communicating with Modbus slaves over RS232/485 (via RTU protocol). </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3dbd315a6e62987c587d8cdadd1abfc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ModbusMaster485::ModbusMaster485 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Creates class object using default serial port 0, Modbus slave ID 1. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9b2abc8616c7c87d86f882a5d10fd307"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModbusMaster485::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize class object.</p>
<p>Sets up the serial port using default 19200 baud rate. Call once class has been instantiated, typically within setup(). </p>

</div>
</div>
<a class="anchor" id="a5428ccaaa7d790a5fd10c585429c841f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModbusMaster485::clearResponseBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear Modbus response buffer.</p>
<dl class="section see"><dt>See also</dt><dd>ModbusMaster::getResponseBuffer(uint8_t u8Index) </dd></dl>

</div>
</div>
<a class="anchor" id="aa1957373b3f6da34f5821ed1db4b8b20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModbusMaster485::clearTransmitBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear Modbus transmit buffer.</p>
<dl class="section see"><dt>See also</dt><dd>ModbusMaster::setTransmitBuffer(uint8_t u8Index, uint16_t u16Value) </dd></dl>

</div>
</div>
<a class="anchor" id="a01d677f6eccd79b431444ce07f7ca10f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t ModbusMaster485::getResponseBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve data from response buffer.</p>
<dl class="section see"><dt>See also</dt><dd>ModbusMaster::clearResponseBuffer() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u8Index</td><td>index of response buffer array (0x00..0x3F) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value in position u8Index of response buffer (0x0000..0xFFFF) </dd></dl>

</div>
</div>
<a class="anchor" id="a139739234cf9199546781d43a6d4ed6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ModbusMaster485::idle </td>
          <td>(</td>
          <td class="paramtype">void(*)()&#160;</td>
          <td class="paramname"><em>idle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set idle time callback function (cooperative multitasking).</p>
<p>This function gets called in the idle time between transmission of data and response from slave. Do not call functions that read from the serial buffer that is used by ModbusMaster. Use of i2c/TWI, 1-Wire, other serial ports, etc. is permitted within callback function.</p>
<dl class="section see"><dt>See also</dt><dd>ModbusMaster::ModbusMasterTransaction() </dd></dl>

</div>
</div>
<a class="anchor" id="ab5945a5c60765f44b64a610e8dadea85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::maskWriteRegister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16AndMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16OrMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x16 Mask Write Register.</p>
<p>This function code is used to modify the contents of a specified holding register using a combination of an AND mask, an OR mask, and the register's current contents. The function can be used to set or clear individual bits in the register.</p>
<p>The request specifies the holding register to be written, the data to be used as the AND mask, and the data to be used as the OR mask. Registers are addressed starting at zero.</p>
<p>The function's algorithm is:</p>
<p>Result = (Current Contents &amp;&amp; And_Mask) || (Or_Mask &amp;&amp; (~And_Mask))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16AndMask</td><td>AND mask (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16OrMask</td><td>OR mask (0x0000..0xFFFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a06cca56a5d9dd46229dc87ce172e9a9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readCoils </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16BitQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x01 Read Coils.</p>
<p>This function code is used to read from 1 to 2000 contiguous status of coils in a remote device. The request specifies the starting address, i.e. the address of the first coil specified, and the number of coils. Coils are addressed starting at zero.</p>
<p>The coils in the response buffer are packed as one coil per bit of the data field. Status is indicated as 1=ON and 0=OFF. The LSB of the first data word contains the output addressed in the query. The other coils follow toward the high order end of this word and from low order to high order in subsequent words.</p>
<p>If the returned quantity is not a multiple of sixteen, the remaining bits in the final data word will be padded with zeros (toward the high order end of the word).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of first coil (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16BitQty</td><td>quantity of coils to read (1..2000, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="acb777ac7541ede98f681adbd01434553"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readDiscreteInputs </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16BitQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x02 Read Discrete Inputs.</p>
<p>This function code is used to read from 1 to 2000 contiguous status of discrete inputs in a remote device. The request specifies the starting address, i.e. the address of the first input specified, and the number of inputs. Discrete inputs are addressed starting at zero.</p>
<p>The discrete inputs in the response buffer are packed as one input per bit of the data field. Status is indicated as 1=ON; 0=OFF. The LSB of the first data word contains the input addressed in the query. The other inputs follow toward the high order end of this word, and from low order to high order in subsequent words.</p>
<p>If the returned quantity is not a multiple of sixteen, the remaining bits in the final data word will be padded with zeros (toward the high order end of the word).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of first discrete input (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16BitQty</td><td>quantity of discrete inputs to read (1..2000, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="afdc381f1ada07bbd13a265bdb06bb34f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readHoldingRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x03 Read Holding Registers.</p>
<p>This function code is used to read the contents of a contiguous block of holding registers in a remote device. The request specifies the starting register address and the number of registers. Registers are addressed starting at zero.</p>
<p>The register data in the response buffer is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of holding registers to read (1..125, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a9083f52d2a0a15489e3e6e4ec2458002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readInputRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x04 Read Input Registers.</p>
<p>This function code is used to read from 1 to 125 contiguous input registers in a remote device. The request specifies the starting register address and the number of registers. Registers are addressed starting at zero.</p>
<p>The register data in the response buffer is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first input register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of input registers to read (1..125, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ae9256623255409b33851d79538762c3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readRegiters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>functionCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function for general registers read The request specifies the address and number of registers to be read</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of holding registers to read (1..125, enforced by remote device) </td></tr>
    <tr><td class="paramname">functionCode</td><td>the read function to execute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a27f8118287f05c7db94a5084baade945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::readWriteMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16ReadQty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x17 Read Write Multiple Registers.</p>
<p>This function code performs a combination of one read operation and one write operation in a single MODBUS transaction. The write operation is performed before the read. Holding registers are addressed starting at zero.</p>
<p>The request specifies the starting address and number of holding registers to be read as well as the starting address, and the number of holding registers. The data to be written is specified in the transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16ReadAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16ReadQty</td><td>quantity of holding registers to read (1..125, enforced by remote device) </td></tr>
    <tr><td class="paramname">u16WriteAddress</td><td>address of the first holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteQty</td><td>quantity of holding registers to write (1..121, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a471792408d5d0d77011ad4e5c7229b03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::setTransmitBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8Index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16Value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Place data in transmit buffer.</p>
<dl class="section see"><dt>See also</dt><dd>ModbusMaster::clearTransmitBuffer() </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u8Index</td><td>index of transmit buffer array (0x00..0x3F) </td></tr>
    <tr><td class="paramname">u16Value</td><td>value to place in position u8Index of transmit buffer (0x0000..0xFFFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a9e2e723b0627d4c9aefb9b727c7c23b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::writeMultipleCoils </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16BitQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x0F Write Multiple Coils.</p>
<p>This function code is used to force each coil in a sequence of coils to either ON or OFF in a remote device. The request specifies the coil references to be forced. Coils are addressed starting at zero.</p>
<p>The requested ON/OFF states are specified by contents of the transmit buffer. A logical '1' in a bit position of the buffer requests the corresponding output to be ON. A logical '0' requests it to be OFF.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the first coil (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16BitQty</td><td>quantity of coils to write (1..2000, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="ac099952a39d535c810a9216bfbb3486a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::writeMultipleRegisters </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteQty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x10 Write Multiple Registers.</p>
<p>This function code is used to write a block of contiguous registers (1 to 123 registers) in a remote device.</p>
<p>The requested written values are specified in the transmit buffer. Data is packed as one word per register.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteQty</td><td>quantity of holding registers to write (1..123, enforced by remote device) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a03bdb4cd84a5e0a09d4250d221ad0795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::writeSingleCoil </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>u8State</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x05 Write Single Coil.</p>
<p>This function code is used to write a single output to either ON or OFF in a remote device. The requested ON/OFF state is specified by a constant in the state field. A non-zero value requests the output to be ON and a value of 0 requests it to be OFF. The request specifies the address of the coil to be forced. Coils are addressed starting at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the coil (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u8State</td><td>0=OFF, non-zero=ON (0x00..0xFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<a class="anchor" id="a86c8f0ba40f2c16b33a6f84a6538bcc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t ModbusMaster485::writeSingleRegister </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>u16WriteValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modbus function 0x06 Write Single Register.</p>
<p>This function code is used to write a single holding register in a remote device. The request specifies the address of the register to be written. Registers are addressed starting at zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">u16WriteAddress</td><td>address of the holding register (0x0000..0xFFFF) </td></tr>
    <tr><td class="paramname">u16WriteValue</td><td>value to be written to holding register (0x0000..0xFFFF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success; exception number on failure </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ab8e16e9a1819d2fb46f3a3e03021da02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBIllegalDataAddress = 0x02</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modbus protocol illegal data address exception.</p>
<p>The data address received in the query is not an allowable address for the server (or slave). More specifically, the combination of reference number and transfer length is invalid. For a controller with 100 registers, the ADU addresses the first register as 0, and the last one as 99. If a request is submitted with a starting register address of 96 and a quantity of registers of 4, then this request will successfully operate (address-wise at least) on registers 96, 97, 98, 99. If a request is submitted with a starting register address of 96 and a quantity of registers of 5, then this request will fail with Exception Code 0x02 "Illegal Data Address" since it attempts to operate on registers 96, 97, 98, 99 and 100, and there is no register with address</p><ol type="1">
<li></li>
</ol>

</div>
</div>
<a class="anchor" id="a393b0b7ea005a15cb3d88bad75bdcdf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBIllegalDataValue = 0x03</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modbus protocol illegal data value exception.</p>
<p>A value contained in the query data field is not an allowable value for server (or slave). This indicates a fault in the structure of the remainder of a complex request, such as that the implied length is incorrect. It specifically does NOT mean that a data item submitted for storage in a register has a value outside the expectation of the application program, since the MODBUS protocol is unaware of the significance of any particular value of any particular register. </p>

</div>
</div>
<a class="anchor" id="a7057a8d96e13d4aef825efb4598f08c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBIllegalFunction = 0x01</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modbus protocol illegal function exception.</p>
<p>The function code received in the query is not an allowable action for the server (or slave). This may be because the function code is only applicable to newer devices, and was not implemented in the unit selected. It could also indicate that the server (or slave) is in the wrong state to process a request of this type, for example because it is unconfigured and is being asked to return register values. </p>

</div>
</div>
<a class="anchor" id="a4b903c24f9893f0f3cd045e1d0b6cdeb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBInvalidCRC = 0xE3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ModbusMaster invalid response CRC exception.</p>
<p>The CRC in the response does not match the one calculated. </p>

</div>
</div>
<a class="anchor" id="a0cef4e3625e700c5893a6f2566740d20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBInvalidFunction = 0xE1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ModbusMaster invalid response function exception.</p>
<p>The function code in the response does not match that of the request. </p>

</div>
</div>
<a class="anchor" id="a8c6645d913b0149ebb97ecba35d0a99d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBInvalidSlaveID = 0xE0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ModbusMaster invalid response slave ID exception.</p>
<p>The slave ID in the response does not match that of the request. </p>

</div>
</div>
<a class="anchor" id="a16a3978380bf0be30685dc082452a13f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBResponseTimedOut = 0xE2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ModbusMaster response timed out exception.</p>
<p>The entire response was not received within the timeout period, ModbusMaster::ku8MBResponseTimeout. </p>

</div>
</div>
<a class="anchor" id="aca7c2882e4cfd65b9eac00ba1f5d1f23"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBSlaveDeviceFailure = 0x04</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Modbus protocol slave device failure exception.</p>
<p>An unrecoverable error occurred while the server (or slave) was attempting to perform the requested action. </p>

</div>
</div>
<a class="anchor" id="a4cf669f82295bd503124df2420d6269a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t ModbusMaster485::ku8MBSuccess = 0x00</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ModbusMaster success.</p>
<p>Modbus transaction was successful; the following checks were valid:</p><ul>
<li>slave ID</li>
<li>function code</li>
<li>response code</li>
<li>data</li>
<li>CRC </li>
</ul>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/Daniel/Dropbox/RockMonitoring/02_Software/RockMonitoring/libraries/libraries/ModbusMaster485/<a class="el" href="_modbus_master485_8h_source.html">ModbusMaster485.h</a></li>
<li>C:/Users/Daniel/Dropbox/RockMonitoring/02_Software/RockMonitoring/libraries/libraries/ModbusMaster485/ModbusMaster485.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
